#Requires -Version 7.0
<#
.SYNOPSIS
    Common functions for data collection with integrated configuration
#>

#region Configuration
$script:Config = @{
    Modules = @{
        BasePath = "Modules"
        Common = "Common.Functions.psm1"
    }
    Paths = @{
        CSV = "D:\ID-Tool\Import\CSVs"
        Temp = "D:\ID-Tool\Import\temp"
        Backup = "D:\ID-Tool\Import\Backup"
        Error = "D:\ID-Tool\Import\Error"
    }
    EntraID = @{
        TenantId = "thomasmartingrome.onmicrosoft.com"
        ClientId = "f8091812-4a88-44c6-9c1d-4ea5abe1bda6"
        CertificateThumbprint = "97a1540bc199dd4406d48101073879ba2573390e"
        BatchSize = 999
        ParallelThrottle = 10
        RateLimitDelayMs = 10
        RetryAttempts = 3
        RetryDelaySeconds = 5
        MemoryThresholdGB = 12
        MemoryWarningThresholdGB = 10
        TargetGroup = $null
        ScopeToGroup = $false
    }
    ActiveDirectory = @{
        BufferLimit = 1000
    }
    FileManagement = @{
        SizeThresholdPercent = 20
        DateFormat = "yyyyMMdd_HHmmss"
    }
    FilePrefixes = @{
        EntraUsers = "EntraUsers-BasicData"
        EntraPermissions = "EntraUsers-Permissions"
        EntraGroups = "EntraUsers-Groups"
        EntraGraphPermissions = "EntraUsers-GraphPermissions"
    }
    Metrics = @{
        StaleAccountThresholdDays = 90
        HashTableLimits = @{
            UniqueUsers = 500000
            UniqueGroups = 5000000
            UniqueRoles = 500000
            UniqueApplications = 500000
        }
        MemoryCheckInterval = 50000
    }
}

function Get-Config {
    param (
        [string]$ConfigPath = $null  # Parameter kept for compatibility but ignored
    )
    
    return $script:Config
}

function Set-ConfigValue {
    param (
        [Parameter(Mandatory)]
        [string]$Path,
        
        [Parameter(Mandatory)]
        $Value
    )
    
    $parts = $Path -split '\.'
    $current = $script:Config
    
    for ($i = 0; $i -lt $parts.Count - 1; $i++) {
        if (-not $current.ContainsKey($parts[$i])) {
            $current[$parts[$i]] = @{}
        }
        $current = $current[$parts[$i]]
    }
    
    $current[$parts[-1]] = $Value
}
#endregion

#region Path Management
function Initialize-DataPaths {
    param (
        [Parameter(Mandatory)]
        [object]$Config
    )
    
    foreach ($path in $Config.Paths.PSObject.Properties.Value) {
        if (-not (Test-Path $path)) {
            New-Item -ItemType Directory -Path $path -Force | Out-Null
        }
    }
}
#endregion

#region File Management
function Move-ProcessedCSV {
    param (
        [Parameter(Mandatory)]
        [string]$SourcePath,
        
        [Parameter(Mandatory)]
        [string]$FinalFileName,
        
        [Parameter(Mandatory)]
        [object]$Config
    )
    
    if (-not (Test-Path $SourcePath)) {
        return
    }
    
    $finalPath = Join-Path $Config.Paths.CSV $FinalFileName
    $sourceSize = (Get-Item $SourcePath).Length
    
    # Check existing file
    if (Test-Path $finalPath) {
        $existingSize = (Get-Item $finalPath).Length
        $sizeDiffPercent = [Math]::Abs(($sourceSize - $existingSize) / $existingSize * 100)
        
        if ($sizeDiffPercent -gt $Config.FileManagement.SizeThresholdPercent) {
            # Move to error folder
            $errorPath = Join-Path $Config.Paths.Error "$FinalFileName`_$(Get-Date -Format $Config.FileManagement.DateFormat)_SizeMismatch.csv"
            Move-Item -Path $SourcePath -Destination $errorPath -Force
            
            $logContent = @"
Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
Error: Size Mismatch
Size Difference: $([Math]::Round($sizeDiffPercent, 1))%
Source Size: $sourceSize bytes
Existing Size: $existingSize bytes
"@
            Set-Content -Path "$errorPath.log" -Value $logContent
            
            Write-Warning "File size difference ($([Math]::Round($sizeDiffPercent, 1))%) exceeds threshold. File moved to: $errorPath"
            return
        }
        
        # Backup existing
        $backupPath = Join-Path $Config.Paths.Backup "$FinalFileName`_$(Get-Date -Format $Config.FileManagement.DateFormat).csv"
        Copy-Item -Path $finalPath -Destination $backupPath -Force
    }
    
    # Move to final location
    Move-Item -Path $SourcePath -Destination $finalPath -Force
    Write-Host "CSV saved to: $finalPath"
}
#endregion

#region Memory Management
function Test-MemoryPressure {
    param (
        [double]$ThresholdGB,
        [double]$WarningGB
    )
    
    $currentMemory = (Get-Process -Id $pid).WorkingSet64 / 1GB
    
    if ($currentMemory -gt $ThresholdGB) {
        Write-Warning "Memory usage critical: $([Math]::Round($currentMemory, 2))GB"
        [System.GC]::Collect()
        [System.GC]::WaitForPendingFinalizers()
        [System.GC]::Collect()
        Start-Sleep -Seconds 2
        return $true
    }
    elseif ($currentMemory -gt $WarningGB) {
        Write-Warning "Memory usage high: $([Math]::Round($currentMemory, 2))GB"
    }
    
    return $false
}

function Write-BufferToFile {
    param (
        [Parameter(Mandatory)]
        [System.Collections.Generic.List[string]]$Buffer,
        
        [Parameter(Mandatory)]
        [string]$FilePath
    )
    
    if ($Buffer.Count -gt 0) {
        $Buffer | Add-Content -Path $FilePath -Encoding UTF8
        $Buffer.Clear()
    }
}
#endregion

#region Progress Management
function Save-Progress {
    param (
        [Parameter(Mandatory)]
        [hashtable]$Progress,
        
        [Parameter(Mandatory)]
        [string]$ProgressFile
    )
    
    $Progress | ConvertTo-Json -Depth 10 | Set-Content -Path $ProgressFile
}

function Get-Progress {
    param (
        [Parameter(Mandatory)]
        [string]$ProgressFile
    )
    
    if (Test-Path $ProgressFile) {
        Write-Host "Resuming from previous progress..."
        return Get-Content $ProgressFile | ConvertFrom-Json -AsHashtable
    }
    
    return $null
}
#endregion

#region Date Standardization
function Convert-ToStandardDateTime {
    param (
        [object]$DateValue,
        [string]$SourceFormat = "Auto"
    )
    
    # Return empty string for null/empty values
    if ($null -eq $DateValue -or $DateValue -eq '' -or $DateValue -eq 0) {
        return ""
    }
    
    try {
        switch ($SourceFormat) {
            'GraphAPI' {
                # Handle Microsoft Graph API ISO 8601 format
                $date = [DateTime]::Parse($DateValue, [System.Globalization.CultureInfo]::InvariantCulture, [System.Globalization.DateTimeStyles]::RoundtripKind)
                return $date.ToString("yyyy-MM-dd HH:mm:ss", [System.Globalization.CultureInfo]::InvariantCulture)
            }
            'LDAP' {
                # Handle LDAP datetime format (from AD.Functions.psm1)
                $dateString = if ($DateValue -is [byte[]]) {
                    [System.Text.Encoding]::UTF8.GetString($DateValue)
                }
                else {
                    $DateValue.ToString()
                }
                
                if ($dateString -match '(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})') {
                    $date = [DateTime]::ParseExact(
                        $matches[1..6] -join '',
                        'yyyyMMddHHmmss',
                        [System.Globalization.CultureInfo]::InvariantCulture
                    )
                    return $date.ToString("yyyy-MM-dd HH:mm:ss", [System.Globalization.CultureInfo]::InvariantCulture)
                }
                
                $date = [DateTime]::Parse($dateString)
                return $date.ToString("yyyy-MM-dd HH:mm:ss", [System.Globalization.CultureInfo]::InvariantCulture)
            }
            'FileTime' {
                # Handle Windows FileTime format (from AD.Functions.psm1)
                $fileTimeValue = if ($DateValue -is [byte[]]) {
                    [BitConverter]::ToInt64($DateValue, 0)
                }
                else {
                    [Int64]::Parse($DateValue.ToString())
                }
                
                if ($fileTimeValue -eq 0 -or 
                    $fileTimeValue -eq [Int64]::MaxValue -or 
                    $fileTimeValue -eq 9223372036854775807) {
                    return ""
                }
                
                return [DateTime]::FromFileTime($fileTimeValue).ToString("yyyy-MM-dd HH:mm:ss", [System.Globalization.CultureInfo]::InvariantCulture)
            }
            'Epoch' {
                # Handle Unix epoch seconds
                $epochSeconds = [double]$DateValue
                $date = [DateTime]::UnixEpoch.AddSeconds($epochSeconds)
                return $date.ToString("yyyy-MM-dd HH:mm:ss", [System.Globalization.CultureInfo]::InvariantCulture)
            }
            default {
                # Auto-detect format
                $stringValue = $DateValue.ToString()
                
                # Check for Graph API format (ISO 8601 with Z or offset)
                if ($stringValue -match '^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}') {
                    return Convert-ToStandardDateTime -DateValue $DateValue -SourceFormat 'GraphAPI'
                }
                
                # Check for LDAP format (yyyyMMddHHmmss)
                if ($stringValue -match '^\d{14}') {
                    return Convert-ToStandardDateTime -DateValue $DateValue -SourceFormat 'LDAP'
                }
                
                # Check for epoch (numeric)
                if ($DateValue -is [int] -or $DateValue -is [long] -or $DateValue -is [double]) {
                    # If it's a large number, assume FileTime; if smaller, assume Epoch
                    if ([long]$DateValue -gt 100000000000) {
                        return Convert-ToStandardDateTime -DateValue $DateValue -SourceFormat 'FileTime'
                    }
                    else {
                        return Convert-ToStandardDateTime -DateValue $DateValue -SourceFormat 'Epoch'
                    }
                }
                
                # Default: try to parse as standard datetime
                $date = [DateTime]::Parse($stringValue, [System.Globalization.CultureInfo]::InvariantCulture)
                return $date.ToString("yyyy-MM-dd HH:mm:ss", [System.Globalization.CultureInfo]::InvariantCulture)
            }
        }
    }
    catch {
        Write-Warning "Failed to convert date value '$DateValue': $_"
        return ""
    }
}
#endregion

#region Connection Management
function Connect-ToGraph {
    param (
        [Parameter(Mandatory)]
        [object]$Config,
        
        [int]$RetryCount = 0
    )
    
    $maxRetries = $Config.RetryAttempts
    
    while ($RetryCount -lt $maxRetries) {
        try {
            Connect-MgGraph -ClientId $Config.ClientId `
                           -TenantId $Config.TenantId `
                           -CertificateThumbprint $Config.CertificateThumbprint `
                           -NoWelcome
            
            $context = Get-MgContext
            if ($context) {
                Write-Host "Successfully connected to Graph API"
                return $true
            }
        }
        catch {
            $RetryCount++
            if ($RetryCount -lt $maxRetries) {
                Write-Warning "Graph connection failed, attempt $RetryCount of $maxRetries. Retrying in $($Config.RetryDelaySeconds) seconds..."
                Start-Sleep -Seconds $Config.RetryDelaySeconds
            }
            else {
                throw "Failed to connect to Graph API after $maxRetries attempts: $_"
            }
        }
    }
    
    return $false
}
#endregion

#region API Request Management
function Invoke-GraphWithRetry {
    param (
        [Parameter(Mandatory)]
        [string]$Uri,
        
        [Parameter(Mandatory)]
        [object]$Config,
        
        [string]$Method = "GET",
        
        [int]$RetryCount = 0
    )
    
    $maxRetries = $Config.RetryAttempts
    
    while ($RetryCount -lt $maxRetries) {
        try {
            $result = Invoke-MgGraphRequest -Uri $Uri -Method $Method
            return $result
        }
        catch {
            $statusCode = $_.Exception.Response.StatusCode.value__
            
            if ($statusCode -eq 429) {
                # Rate limited - check for Retry-After header
                $retryAfter = 60
                if ($_.Exception.Response.Headers.RetryAfter) {
                    $retryAfter = $_.Exception.Response.Headers.RetryAfter.Delta.TotalSeconds
                }
                Write-Warning "Rate limited. Waiting $retryAfter seconds..."
                Start-Sleep -Seconds $retryAfter
                # Don't count rate limit against retry count
                continue
            }
            
            $RetryCount++
            if ($RetryCount -lt $maxRetries) {
                Write-Warning "Graph request failed, attempt $RetryCount of $maxRetries. Retrying in $($Config.RetryDelaySeconds) seconds..."
                Start-Sleep -Seconds $Config.RetryDelaySeconds
            }
            else {
                throw "Graph request failed after $maxRetries attempts: $_"
            }
        }
    }
}

function Get-GraphBatch {
    param($NextLink, $Config)
    $response = Invoke-MgGraphRequest -Method GET -Uri $NextLink
    return @{
        Items = $response.value
        NextLink = $response.'@odata.nextLink'
    }
}
#endregion

#region Paging Functions
function Invoke-GraphRequestWithPaging {
    param (
        [string]$Uri,
        [object]$Config
    )
    $results = [System.Collections.ArrayList]::new()
    $currentUri = $Uri
    do {
        $response = Invoke-GraphWithRetry -Uri $currentUri -Config $Config
        if ($response.value) {
            [void]$results.AddRange($response.value)
        }
        $currentUri = $response.'@odata.nextLink'
    } while ($currentUri)
    return $results
}
#endregion

#region Group Filtering Functions
function Get-InitialUserQuery {
    param (
        [Parameter(Mandatory)]
        [object]$Config,
        [Parameter(Mandatory)]
        [string]$SelectFields,
        [Parameter(Mandatory)]
        [int]$BatchSize
    )
    if ($Config.ScopeToGroup -and $Config.TargetGroup) {
        Write-Host "Scoping collection to group: $($Config.TargetGroup)"
        # Get the group ID
        $groupResponse = Invoke-GraphWithRetry `
            -Uri "https://graph.microsoft.com/v1.0/groups?`$filter=displayName eq '$($Config.TargetGroup)'" `
            -Config $Config
        if (-not $groupResponse.value -or $groupResponse.value.Count -eq 0) {
            throw "Group '$($Config.TargetGroup)' not found in tenant"
        }
        $groupId = $groupResponse.value[0].id
        Write-Host "Found group ID: $groupId"
        return "https://graph.microsoft.com/v1.0/groups/$groupId/members?`$select=$SelectFields&`$top=$BatchSize"
    }
    else {
        Write-Host "Collecting all users in tenant"
        return "https://graph.microsoft.com/v1.0/users?`$select=$SelectFields&`$top=$BatchSize"
    }
}
#endregion

Export-ModuleMember -Function @(
    'Get-Config',
    'Set-ConfigValue',
    'Initialize-DataPaths',
    'Move-ProcessedCSV',
    'Test-MemoryPressure',
    'Write-BufferToFile',
    'Save-Progress',
    'Get-Progress',
    'Convert-ToStandardDateTime',
    'Connect-ToGraph',
    'Invoke-GraphWithRetry',
    'Get-GraphBatch',
    'Invoke-GraphRequestWithPaging',
    'Get-InitialUserQuery'
)